(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{406:function(t,a,e){"use strict";e.r(a);var v=e(54),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"计算属性和watch监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算属性和watch监听"}},[t._v("#")]),t._v(" 计算属性和watch监听")]),t._v(" "),e("p",[t._v("当结果需要复用的时候，可以使用计算属性来实现")]),t._v(" "),e("p",[t._v("计算属性写法上像函数，但是本质上是属性")]),t._v(" "),e("p",[t._v("计算属性中 必须写return")]),t._v(" "),e("h3",{attrs:{id:"计算属性和方法的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算属性和方法的区别"}},[t._v("#")]),t._v(" 计算属性和方法的区别：")]),t._v(" "),e("p",[t._v("​\t计算属性是基于它们的"),e("strong",[t._v("响应式依赖")]),t._v("进行缓存的")]),t._v(" "),e("p",[t._v("​\t 只有在相关响应式依赖发生改变，才会重新计算结果，如果没有改变，那么计算属性会立即返回之前的计算结果相比之下，每当重新渲染的时候，调用函数总会再次执行")]),t._v(" "),e("h1",{attrs:{id:"watch监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch监听"}},[t._v("#")]),t._v(" watch监听：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/image-20210902152724688.png",alt:"image-20210820104406553"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/image-20210902152747674.png",alt:"image-20210820104406553"}})]),t._v(" "),e("p",[t._v("deep:是否进行深度监听")]),t._v(" "),e("p",[t._v("immediate:开始监听的时候，立即执行一次回调函数")]),t._v(" "),e("p",[e("strong",[t._v("computed和watch的区别：")])]),t._v(" "),e("p",[t._v("1.computed支持缓存，watch不支持缓存，数据变，直接触发相应的操作")]),t._v(" "),e("p",[t._v("2.computed不支持异步，当计算属性内有异步操作时无效，无法监听数据的变化，watch支持异步")]),t._v(" "),e("p",[t._v("3.computed没有参数，基于计算属性的响应式依赖进行缓存，watch接受两个参数")]),t._v(" "),e("p",[t._v("4.computed中有get()和set()方法，watch只是监听到数据变化，执行函数")])])}),[],!1,null,null,null);a.default=_.exports}}]);