(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{408:function(t,n,r){"use strict";r.r(n);var e=r(54),o=Object(e.a)({},(function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"vue的路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue的路由"}},[t._v("#")]),t._v(" vue的路由")]),t._v(" "),r("p",[t._v("vur-router")]),t._v(" "),r("h3",{attrs:{id:"什么路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么路由"}},[t._v("#")]),t._v(" 什么路由？")]),t._v(" "),r("p",[t._v("​\tvue.js深度集成的路由管理器")]),t._v(" "),r("h3",{attrs:{id:"为什么使用路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用路由"}},[t._v("#")]),t._v(" 为什么使用路由？")]),t._v(" "),r("p",[t._v("​\t实现vue的按需加载（组件），主要实现结合传统路径的跳转方式实现页面（组件）的跳转\n​\ta\n​\ta")]),t._v(" "),r("p",[r("strong",[t._v("路由是干什么？")])]),t._v(" "),r("p",[t._v("​\t实现组件的切换（方便）")]),t._v(" "),r("p",[r("strong",[t._v("使用路由有什么好处（优点）")]),t._v("\n方便、集中管理，按需加载，代码冗余，解耦合")]),t._v(" "),r("p",[r("strong",[t._v("安装方法：")])]),t._v(" "),r("p",[t._v("第一步：官网\n第二步：使用（安装）\nnpm install vue-router（最新版本）")]),t._v(" "),r("p",[t._v("配置")]),t._v(" "),r("p",[t._v("导出实例")]),t._v(" "),r("p",[t._v("main.js")]),t._v(" "),r("p",[t._v("this.$router // 路由实例\nthis.$route // 当前访问的路由对象")]),t._v(" "),r("p",[r("strong",[t._v("vue-router内置了两个组件：")])]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("声明式：")])]),t._v(" "),r("p",[t._v("​\t\t"),r("router-link"),t._v(" 跳转方式（声明式）\n​\t\tto:跳转路径\n​\t\ttag:转换标签，默认是a")],1),t._v(" "),r("p",[t._v("​\t\t"),r("router-view"),t._v(" 组件显示方式")],1),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("编程式：")]),t._v("\n​\t\t两种方式：\n​\t\t\tthis.$router.push({path：'/my'}) // "),r("strong",[t._v("会往记录栈添加一条记录")]),t._v("\n​\t\t\tthis.$router.replace() // "),r("strong",[t._v("不会往记录栈添加一条记录，替换记录")])]),t._v(" "),r("p",[t._v("​\t\t"),r("strong",[t._v("两种形式：")]),t._v("\n​\t\t\tpath：跳转路径， 传递query参数-体现在url上\n​\t\t\tname: 命名路由， 传递query参数-体现在url上，传递params参数-体现在路由对象的path上（动态路径参数）\n​\tname: 命名视图")]),t._v(" "),r("h3",{attrs:{id:"路由有两种模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由有两种模式"}},[t._v("#")]),t._v(" 路由有两种模式：")]),t._v(" "),r("p",[t._v("​\thash 哈希 （hash）默认模式\n​\t\thttp://localhost:8080/#/main （#/）\n​\t历史模式（history）\n​\t\thttp://localhost:8080/main")]),t._v(" "),r("p",[t._v("​\t以路由的方式跳转，必须以路由的方式显示组件\n​\t"),r("strong",[t._v("history和hash的区别：")]),t._v("\n​\t\t1.hash不会向服务器发起请求\n​\t\t2.hash有#\n​\t\t3.hash兼容性好，history利用的是h5的新特性\n​\t\t3.history.pushState       history.replaceState\n​\t\t\thistory使用的是history.pushState和history.replaceState进行跳转\n​\t\t4.hash可以触发 hashchange事件")]),t._v(" "),r("p",[r("strong",[t._v("什么是路由导航？")]),t._v("\n拦截路由跳转")]),t._v(" "),r("p",[r("strong",[t._v("路由导航的目的？")]),t._v("\n跳转之前、跳转过程中、跳转之后（做一些行为逻辑的操作）")]),t._v(" "),r("p",[r("strong",[t._v("路由导航守卫分为三大类：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("1.全局导航守卫\n\ta.全局前置导航守卫（页面跳转之前）\n\t\tto: Route: 即将要进入的目标 路由对象\n\t\tfrom: Route: 当前导航正要离开的路由\n\t\tnext: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n\n\t\trouter.beforeEach((to, from, next) => {\n \t \t\t// ...\n\t\t})\n\n\tb.全局后置导航守卫（页面跳转之后）\n\t\trouter.afterEach((to, from) => {\n  \t\t// ...\n\t\t})\n\n2.路由独享的导航守卫\n\t进入页面之前先执行路由对象的beforeEnter，执行next\n\tbeforeEnter: (to, from, next) => {\n\t\t// ...\n\t}\n\n3.组件内的导航守卫\n\tbeforeRouteEnter(to, from, next) {\n    \t// 在渲染该组件的对应路由被 confirm 前调用\n    \t// 不！能！获取组件实例 `this`\n    \t// 因为当守卫执行前，组件实例还没被创建\n  \t},\n  \tbeforeRouteUpdate(to, from, next) {\n    \t// 在当前路由改变，但是该组件被复用时调用\n    \t// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    \t// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    \t// 可以访问组件实例 `this`\n  \t},\n  \tbeforeRouteLeave(to, from, next) {\n    \t// 导航离开该组件的对应路由时调用\n    \t// 可以访问组件实例 `this`\n  \t}\n\n\tbeforeRouteEnter 守卫 不能 访问 this，因为他在组件创建之前触发执行的。\n")])])]),r("p",[r("strong",[t._v("数据驱动视图")]),t._v("\nmvvm\n尽量不要操作dom，万不得已的时候，使用vue提供一个api，this.$refs\n一定不要操作dom")])])}),[],!1,null,null,null);n.default=o.exports}}]);